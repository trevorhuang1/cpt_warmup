---
toc: true
comments: false
layout: base
title: Stego Things
description: This is for stego things
type: hacks
courses: { compsci: {week: 0} }
---

# Stego things:

<!-- Input for selecting an image file -->
<input type="file" id="imageInput" accept="image/*">
<!-- Textarea for entering the message to be encoded -->
<textarea id="messageInput" placeholder="Enter your message"></textarea>
<!-- Button to trigger the encoding process -->
<button onclick="encodeMessage()">Encode Message</button>
<!-- Canvas element for drawing and displaying the encoded image -->
<canvas id="canvas"></canvas>

<script>
    // Function to encode a message into an image
    function encodeMessage() {
        // Get HTML elements
        const imageInput = document.getElementById('imageInput');
        const messageInput = document.getElementById('messageInput');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Create a new Image object and load the selected image
        const image = new Image();
        image.src = URL.createObjectURL(imageInput.files[0]);

        // Callback executed when the image is loaded
        image.onload = function () {
            // Set canvas dimensions to match the image
            canvas.width = image.width;
            canvas.height = image.height;

            // Draw the image onto the canvas
            ctx.drawImage(image, 0, 0);

            // Get the message from the input and convert it to binary
            const message = messageInput.value;
            const binaryMessage = stringToBinary(message);

            let binaryIndex = 0;

            // Loop through each pixel of the image
            for (let y = 0; y < image.height; y++) {
                for (let x = 0; x < image.width; x++) {
                    // Get the RGBA data of the current pixel
                    const pixel = ctx.getImageData(x, y, 1, 1);
                    const rgba = pixel.data;

                    // Loop through RGB components (ignoring alpha)
                    for (let i = 0; i < 3; i++) {
                        if (binaryIndex < binaryMessage.length) {
                            // Set the least significant bit of each RGB component to the message bit
                            rgba[i] = (rgba[i] & 0xFE) | parseInt(binaryMessage[binaryIndex], 2);
                            binaryIndex++;
                        }
                    }

                    // Update the pixel data on the canvas
                    ctx.putImageData(new ImageData(new Uint8ClampedArray(rgba), 1, 1), x, y);
                }
            }
            // Store the length of the binary message for decoding
            window.binaryMessageLength = binaryMessage.length;
        };
    }

    // Function to decode a message from an encoded image
    function decodeMessage() {
        // Get HTML elements
        const encodedImageInput = document.getElementById('encodedImageInput');
        const decodedMessageTextarea = document.getElementById('decodedMessage');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Create a new Image object and load the encoded image
        const encodedImage = new Image();
        encodedImage.src = URL.createObjectURL(encodedImageInput.files[0]);

        // Callback executed when the encoded image is loaded
        encodedImage.onload = function () {
            // Set canvas dimensions to match the encoded image
            canvas.width = encodedImage.width;
            canvas.height = encodedImage.height;

            // Draw the encoded image onto the canvas
            ctx.drawImage(encodedImage, 0, 0);

            let binaryMessage = '';
            // Loop through each pixel of the encoded image
            for (let y = 0; y < encodedImage.height; y++) {
                for (let x = 0; x < encodedImage.width; x++) {
                    // Get the RGBA data of the current pixel
                    const pixel = ctx.getImageData(x, y, 1, 1).data;
                    if (binaryMessage.length < binaryMessageLength) {
                        // Loop through RGB components (ignoring alpha)
                        for (let i = 0; i < 3; i++) {
                            // Extract the least significant bit from each RGB component
                            binaryMessage += (pixel[i] & 1).toString();
                        }
                    }
                }
            }

            // Convert the binary message to a human-readable string
            const message = binaryToString(binaryMessage);
            // Display the decoded message in the textarea
            decodedMessageTextarea.value = message;
        };
    }

    // Function to convert a string to binary
    function stringToBinary(str) {
        const binary = [];
        for (let i = 0; i < str.length; i++) {
            // Convert each character to its binary representation
            const charCode = str.charCodeAt(i).toString(2);
            // Ensure each binary representation is 8 bits long
            binary.push('0'.repeat(8 - charCode.length) + charCode);
        }
        return binary.join('');
    }

    // Function to convert binary to a string
    function binaryToString(binary) {
        let str = '';
        for (let i = 0; i < binary.length; i += 8) {
            // Convert each 8 bits to a character and concatenate
            const byte = binary.substr(i, 8);
            str += String.fromCharCode(parseInt(byte, 2));
        }
        return str;
    }
</script>


# Stego Decode
<!-- Input for selecting an encoded image file -->
<input type="file" id="encodedImageInput" accept="image/*">
<!-- Button to trigger the decoding process -->
<button onclick="decodeMessage()">Decode Message</button>
<!-- Textarea for displaying the decoded message -->
<textarea id="decodedMessage" placeholder="Decoded message will appear here"></textarea>